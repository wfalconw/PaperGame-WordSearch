<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>randomize();

//INICIA AS VARIAVES DO AMBIENTE

//O quadro sempre será quadrado largura x altura
board_size = 20;

//Cria o quadro na sala
board = ds_grid_create(board_size,board_size);

//Armazena a altura do quadro
board_h = ds_grid_height(board);

//Armazena a largura do quadro
board_w = ds_grid_width(board);

//Qual é o tempo de criação em segundos.
time_to_create=0;

//Quais são as opções de organização
opcoes = "";

//% de chance de virar a palavra
chance = 25;

//Variavel para verificar a letra a ser colocada no quadro
letra_atual = "";

//Verifica se o mouse foi clicado
mouse_pressed = 0;

//Armazena o valor em x do mouse
mouse_xstart = mouse_x;

//Armazena o valor em y do mouse
mouse_ystart = mouse_y;


//*****EDITÁVEL*****//
//Qual é a cor da linha de seleção
line_color = c_blue;

//Qual é a cor do centro do quadro
board_colorA = c_black;

//Qual é a cor das bordas do quadro
board_colorB = c_dkgray;

//Qual é a transparencia do quadro
board_alpha = 0.8;

//Qual é a fonte do quadro
board_font = fnt_base;

//Qual é cor da fonte do quadro
board_font_color = c_white;

//Qual é a cor da fonte quando a palavra é encontrada
board_font_revela_color = c_yellow;

//Qual é a fonte da lista de palavras do lado direito
list_font = fnt_base;

//Qual é a cor da fonte da lista de palavras
list_font_color = c_lime;

//Qual é a cor da fonte da palavra encontrada na lista
list_font_revela_color = c_red;
//*****FIM EDITÁVEL*****//


//Qual é a palavra encontrada
word_find = "";

//Controla se a palavra está invertida ou não
reversed = 0;

//Recebe o valor para verificar se está ou não invertida, 0=Não invertida, 1=Invertida
reversed_find = 0;

//Quantidades de palavras encontradas
amount_words_find = 0;

//Recebe qual é a posição da palavra selecionada pelo "opcoes", horizontal, vertical, diagonal_principal ou diagonal_secundaria
position = "";

//Cria as palavras para adiconar no quadro
words = ds_list_create();

//Ao clicar numa letra, verifica quantas palavras possuem na letra, e adiciona as palavras nesta lista
word_list_pressed = ds_list_create();

//Ao soltar o clique, verifica quantas palavras possuem na letra, e adiciona as palavras nesta lista
word_list_release = ds_list_create();

//Cria a lista de palavras para serem encontradas
words_to_find = ds_list_create();

//Cria um mapa de variaveis para controlar a lista de palavras encontradas
map_lista = ds_map_create();

//Array que controla o ID das celulas no quadro
map_cell[0, 0] = "";

//ID da letra quando clica
cell_pressed = -1;

//ID da letra quando solta
cell_release = -1;

//Controla o ID das letras
cell_id = -1

//Primeiro clique, pega o valor do x do mouse
fcx = -1;

//Primeiro clique, pega o valor do y do mouse
fcy = -1;

//Números de linhas do arquivo chamado banco.txt
num = 0;

//Número de tentativas para adicionar a palavra no quadro
tentativa = 1000;

//Lê o arquivo em Included Files chamado banco.txt
_file = file_text_open_read("banco.txt");

//Enquanto o fim do arquivo não chegar
while(!file_text_eof(_file))
{
    //Armazena a palavra na array str[0]
    str[num] = file_text_read_string(_file);

    //Adiciona na lista de palavras
    ds_list_add(words, string(str[num]));
    
    //Pula uma linha
    if(os_type == os_windows &amp;&amp; os_browser == -1)
    {
        file_text_readln(_file);
    }
    
    //Quantidade de palavvras agora é +1
    num += 1;
}

//Fecha o arquivo de leitura
file_text_close(_file);

//Palavra da vez que será selecionada
word = "";

//Tamanho em letras da palavra. Exemplo: "bola" = 4
word_length = 0;

//Tamanho da lista de palavras para serem encontradas
size_words_to_find = 0;

//Cria uma repetição em x no valor da largura do quadro
for(_xp = 0; _xp &lt; board_h; _xp++)
{
    //Cria uma repetição em x no valor da altura do quadro
    for(_yp = 0;_yp &lt; board_w; _yp++)
    {
        //Para cada letra, cria um mapa para adicionar suas proprias variaveis
        map_cell[_xp, _yp] = ds_map_create();
        
        //Adiciona a id da celula no mapa da letra
        ds_map_add(map_cell[_xp, _yp],"id", -1);
        
        //Adiciona a celula do primeiro clique no mapa da letra
        ds_map_add(map_cell[_xp, _yp],"first", -1);
        
        //Adiciona a celula do ultimo clique no mapa da letra
        ds_map_add(map_cell[_xp, _yp],"last", -1);
        
        //Adiciona a cor no mapa da letra
        ds_map_add(map_cell[_xp, _yp],"cor", board_font_color);
        
        //Adiciona a variavel reversed(se está virada ou não) no mapa da letra
        ds_map_add(map_cell[_xp, _yp], "reversed", 0);
        
        //Adiciona o valor de ativo no mapa da letra, verifica se tem uma palavra contida nesta ceula
        ds_map_add(map_cell[_xp, _yp],"ativo", 0);
    }
}

for(i = 0; i &lt; ds_list_size(words); i++)
{
    word_tentativa[i, 0] = words[|i];
    word_tentativa[i, 1] = tentativa;
}

//Faça
do
{
    //Tempo de criação
    time_to_create += 0.1;
    
    //ESCOLHE A PALAVRA
    
    if(!ds_list_empty(words))
    {
        //Bagunça a lista de palavras criada através da lista criada pelo arquivo.txt em included files
        ds_list_shuffle(words);
        
        //A palavra se torna o primeiro valor da lista bagunçada
        word = words[|0];
    }
    else
    {
        word = "";
    }
    
    for(i = 0; i &lt; array_height_2d(word_tentativa); i++)
    {
        if(word_tentativa[i, 0] == word)
        {
            if(word_tentativa[i, 1] &gt; 0)
            {
                word_tentativa[i, 1] -= 1;
                
                show_debug_message(string(word) + " : " + string(word_tentativa[i, 1]));
            }
            else
            {
                ds_list_delete(words, 0);
                
                if(!ds_list_empty(words))
                {
                    //Bagunça a lista de palavras criada através da lista criada pelo arquivo.txt em included files
                    ds_list_shuffle(words);
                    
                    //A palavra se torna o primeiro valor da lista bagunçada
                    word = words[|0];
                }
                else
                {
                    word = "";
                }
            }
            i = array_height_2d(word_tentativa);
        }
    }
    
    //Pega o tamanho em letras da palavra selecionada
    word_length = string_length(word);
    
    if(word_length &gt; 0)
    {    
        //Escolhe uma opção de organização
        opcoes = choose("horizontal", "vertical", "diagonal_principal", "diagonal_secundaria");
        
        //De acordo com as opções
        switch(opcoes)
        {
            //Se for horizontal
            case "horizontal":
                //Executa o script para criar a palavra na horizontal
                scr_horizontal();
                break;
            //Se for vertical
            case "vertical":
                //Executa o script para criar a palavra na vertical
                scr_vertical();
                break;
            //Se for diagonal principal
            case "diagonal_principal":
                //Executa o script para criar a palavra na diagonal principal
                scr_diagonal_principal();
                break;
            //Se for diagonal secundária
            case "diagonal_secundaria":
                //Executa o script para criar a palavra na diagonal secundária
                scr_diagonal_secundaria();
                break;
        }
    }
    //Se a lista de palavras estiver vazia, ou seja, se já terminou de adicionar todas as palavras
    if(ds_list_empty(words))
    {
        //Faz a repetição no tamanho da largura do quadro
        for(_xp = 0; _xp &lt; board_h; _xp++)
        {
            //Faz a repetição no tamanho da altura do quadro
            for(_yp = 0; _yp &lt; board_w; _yp++)
            {
                //Se não houver nenhuma letra nesta celula
                if(ds_grid_get(board, _xp, _yp) == 0)
                {
                    ds_map_replace(map_cell[_xp, _yp], "cor", board_font_color);
                    
                    //Seleciona uma letra aleatória do alfabeto
                    letter = irandom_range(65, 90);
                    
                    //Seta o valor do quadro para a letra selecionada acima
                    ds_grid_set(board, _xp, _yp, chr(letter));
                }
            }
        }
    }
}
//até que a lista esteja vazia
until ds_list_size(words) == 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_grid_destroy(board);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_angle+=5
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>mouse_pressed = 0;

gx = x_to_gx(mouse_x);
gy = y_to_gy(mouse_y);

if((gx &lt; board_w &amp;&amp; gy &lt; board_h) &amp;&amp; (gx &gt;= 0 &amp;&amp; gy &gt;= 0))
{
    last_cell = ds_map_find_value(map_cell[gx, gy], "last");
    reversed_find = ds_map_find_value(map_cell[gx, gy], "reversed");
    
    if((fcx &gt; gx &amp;&amp; fcy == gy) || (fcx &lt; gx &amp;&amp; fcy == gy))
    {
        position = "horizontal";
    }    
    else if((fcx == gx &amp;&amp; fcy &gt; gy) || (fcx == gx &amp;&amp; fcy &lt; gy))
    {
        position = "vertical";
    }
    else if((fcx &gt; gx &amp;&amp; fcy &gt; gy) || (fcx &lt; gx &amp;&amp; fcy &lt; gy))
    {
        position = "diagonal_principal";
    }
    else
    {
        if((fcx &gt; gx &amp;&amp; fcy &lt; gy) || (fcx &lt; gx &amp;&amp; fcy &gt; gy))
        {
            position = "diagonal_secundaria";
        }
    }
    
    ds_list_clear(word_list_release);

    if(last_cell == -1)
    {
        last_cell = ds_map_find_value(map_cell[gx, gy], "first");
        reversed_find = ds_map_find_value(map_cell[gx, gy], "reversed");
    }
    
    if(last_cell == 1)
    {
        cell_release = ds_map_find_value(map_cell[gx, gy], "id");
        
        if(cell_pressed != cell_release)
        {
            ativo = ds_map_find_value(map_cell[gx, gy], "ativo");
            
            if(ativo &gt; 0)
            {
                for(i = ativo; i &gt; 0; i--)
                {
                    ds_list_add(word_list_release, ds_map_find_value(map_cell[gx, gy],"word_" + string(i)));
                }
                
                size_pressed = ds_list_size(word_list_pressed);
                size_release = ds_list_size(word_list_release);
                
                for(i = 0; i &lt; size_pressed; i++)
                {
                    for(j = 0; j &lt; size_release; j++)
                    {
                        if(word_list_pressed[|i] == word_list_release[|j])
                        {
                            word_find = word_list_pressed[|i];
                            word_find_length = string_length(word_find);
                            
                            if(position == "horizontal")
                            {                            
                                if(gx &lt; fcx)
                                {
                                    for(k = 0; k &lt; word_find_length; k++)
                                    {
                                        ativo = ds_map_find_value(map_cell[gx + k, gy], "ativo");
                                        
                                        if(ativo == 1)
                                        {
                                            ativo -= 1;
                                        }
                                        
                                        ds_map_replace(map_cell[gx + k, gy], "ativo", ativo);
                                        ds_map_replace(map_cell[gx + k, gy], "cor", board_font_revela_color);
                                        
                                        if(reversed_find == 1)
                                        {
                                            word_find = reverseString(word_find);                                    
                                        }
                                        
                                        ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                    }
                                }
                                else
                                {
                                    if(gx &gt; fcx)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx - k, gy], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                            
                                            ds_map_replace(map_cell[gx - k, gy], "ativo", ativo);
                                            ds_map_replace(map_cell[gx - k, gy], "cor", board_font_revela_color);
                                            
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);
                                            }
                                            
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                        }
                                    }
                                }
                            }
                            else if(position == "vertical")
                            {
                                if(gy &lt; fcy)
                                {
                                    for(k = 0; k &lt; word_find_length; k++)
                                    {
                                        ativo = ds_map_find_value(map_cell[gx, gy + k], "ativo");
                                        
                                        if(ativo == 1)
                                        {
                                            ativo -= 1;
                                        }
                                        
                                        ds_map_replace(map_cell[gx, gy + k], "ativo", ativo);
                                        ds_map_replace(map_cell[gx, gy + k], "cor", board_font_revela_color);
                                        
                                        if(reversed_find == 1)
                                        {
                                            word_find = reverseString(word_find);                                    
                                        }
                                        
                                        ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                    }
                                }
                                else
                                {
                                    if(gy &gt; fcy)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx, gy - k], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                            
                                            ds_map_replace(map_cell[gx, gy - k], "ativo", ativo);
                                            ds_map_replace(map_cell[gx, gy - k], "cor", board_font_revela_color);
                                            
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);                                    
                                            }
                                            
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                        }
                                    }
                                }
                            }
                            else if(position == "diagonal_principal")
                            {
                                if(gx &lt; fcx)
                                {
                                    for(k = 0; k &lt; word_find_length; k++)
                                    {
                                        ativo = ds_map_find_value(map_cell[gx + k, gy + k], "ativo");
                                        
                                        if(ativo == 1)
                                        {
                                            ativo -= 1;
                                        }
                                        
                                        ds_map_replace(map_cell[gx + k, gy + k], "ativo", ativo);
                                        ds_map_replace(map_cell[gx + k, gy + k], "cor", board_font_revela_color);
                                        
                                        if(reversed_find == 1)
                                        {
                                            word_find = reverseString(word_find);                                    
                                        }
                                        
                                        ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                    }
                                }
                                else
                                {
                                    if(gx &gt; fcx)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx - k, gy - k], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                            
                                            ds_map_replace(map_cell[gx - k, gy - k], "ativo", ativo);
                                            ds_map_replace(map_cell[gx - k, gy - k], "cor", board_font_revela_color);
                                            
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);                                    
                                            }
                                            
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if(position == "diagonal_secundaria")
                                {
                                    if(gx &lt; fcx)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx + k, gy - k], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                                        
                                            ds_map_replace(map_cell[gx + k, gy - k], "ativo", ativo);
                                            ds_map_replace(map_cell[gx + k, gy - k], "cor", board_font_revela_color);
                                                        
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);                                    
                                            }
                                                        
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                        }
                                    }
                                    else
                                    {
                                        if(gx &gt; fcx)
                                        {
                                            for(k = 0; k &lt; word_find_length; k++)
                                            {
                                                ativo = ds_map_find_value(map_cell[gx - k, gy + k], "ativo");
                                                                
                                                if(ativo == 1)
                                                {
                                                    ativo -= 1;
                                                }
                                                                
                                                ds_map_replace(map_cell[gx - k, gy + k], "ativo", ativo);
                                                ds_map_replace(map_cell[gx - k, gy + k], "cor", board_font_revela_color);
                                                                
                                                if(reversed_find == 1)
                                                {
                                                    word_find = reverseString(word_find);                                    
                                                }
                                                                
                                                ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                            }
                                        }
                                    }
                                }
                            }
                            amount_words_find += 1;
                            
                            if(amount_words_find == ds_list_size(words_to_find))
                            {
                                show_message("Ganhou!");
                            }
                            
                            i = size_pressed;
                            j = size_release;
                        }
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>gx = x_to_gx(mouse_x);
gy = y_to_gy(mouse_y);

if((gx &lt; board_w &amp;&amp; gy &lt; board_h) &amp;&amp; (gx &gt;= 0 &amp;&amp; gy &gt;= 0))
{
    //DESENHA A SELEÇÃO
    mouse_pressed = 1;
    
    mouse_xstart = mouse_x;
    mouse_ystart = mouse_y;
    //FIM DA SELEÇÃO

    first_cell = ds_map_find_value(map_cell[gx, gy], "first");
    ds_list_clear(word_list_pressed);

    if first_cell == -1
    {
        first_cell = ds_map_find_value(map_cell[gx, gy], "last");
    }
    
    if(first_cell == 1)
    {
        fcx = gx;
        fcy = gy;
        
        cell_pressed = ds_map_find_value(map_cell[gx, gy], "id");
        
        ativo = ds_map_find_value(map_cell[gx, gy], "ativo");
        
        if(ativo &gt; 0)
        {            
            for(i = ativo; i &gt; 0; i--)
            {
                ds_list_add(word_list_pressed, ds_map_find_value(map_cell[gx, gy], "word_" + string(i)));
            }
        }
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_grid_destroy(board);
ds_list_destroy(words);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Seta a precisão do circulo.
draw_set_circle_precision(64);

//Desenha o quadro no fundo.
draw_set_alpha(board_alpha);

//Quadro letras
draw_roundrect_colour_ext(x - 16, y - 16, x + (board_w * 32) + 16, y + (board_h * 32) + 16, 32, 32, board_colorA, board_colorB, 0);
draw_roundrect_colour_ext(x - 20, y - 20, x + (board_w * 32) + 20, y + (board_h * 32) + 20, 32, 32, board_colorA, board_colorB, 1);
draw_set_alpha(1);

//Desenha a linha abaixo das letras
if(mouse_pressed == 1)
{
    draw_set_colour(line_color);
    draw_set_alpha(1);
    draw_line_width(mouse_xstart, mouse_ystart, mouse_x, mouse_y, 32);
    draw_circle(mouse_xstart, mouse_ystart, 16, 0);
    draw_circle(mouse_x, mouse_y, 16, 0);
    draw_set_color($FFFFFF);
    draw_set_alpha(1);
}

//Desenha as palavras.
draw_set_font(board_font);

for(_xp = 0; _xp &lt; board_w; _xp++)
{
    for(_yp = 0;_yp &lt; board_h; _yp++)
    {
        draw_set_valign(fa_middle);
        draw_set_halign(fa_center);
        
        cor = ds_map_find_value(map_cell[_xp, _yp], "cor")
        draw_set_colour(cor);
        
        //DESENHA AS LETRAS
        draw_text(x + (_xp * 32) + 16, y + (_yp * 32) + 16, board[#_xp, _yp]);
    }
}

//Desenha o resto das letras.
if(!ds_list_empty(words))
{
    for(i = 0; i &lt; ds_list_size(words); i++)
    {
        draw_text(512, 384 + (32 * i), words[|i]);
    }
}

//Desenha as palavras para serem encontradas
if(size_words_to_find &gt; 0)
{    
    for(i = 0; i &lt; ds_list_size(words_to_find); i++)
    {
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
        
        w = words_to_find[|i];        
        draw_set_colour(ds_map_find_value(map_lista, "cor_" + string(w)));
        
        draw_text(x + 32 + (board_w * 32), y + (32 * i), ds_map_find_value(map_lista, "palavra_" + string(w)));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
