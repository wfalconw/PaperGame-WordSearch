<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init generator

randomize();

//Board settings
board_size = 6;
board = ds_grid_create(board_size,board_size);
board_h = ds_grid_height(board);
board_w = ds_grid_width(board);
time_to_create=0;
board_font = fnt_base;

//Number of attempts to add the word in the frame
tentativa = 64;

//What are the organizational options
opcoes = "";

//% chance to turn the word
chance = 0;

//Variable to check the letter to be placed on the board
letra_atual = "";

//Checks whether the mouse was clicked
mouse_pressed = 0;

//Stores the x value of the mouse
mouse_xstart = mouse_x;

//Stores the y value of the mouse
mouse_ystart = mouse_y;

//Colour settings
line_color = 0;
board_font_color = global.c_ink;
board_font_revela_color = global.c_ink;
list_font = fnt_base;
list_font_color = global.c_ink;
list_font_revela_color = global.c_ink;

//Word Searching Engine Start
word_find = "";
reversed = 0;
reversed_find = 0;
amount_words_find = 0;
position = "";
    words = ds_list_create();
    word_list_pressed = ds_list_create();
    word_list_release = ds_list_create();
    words_to_find = ds_list_create();
    map_lista = ds_map_create();
map_cell[0, 0] = "";
cell_pressed = -1;
cell_release = -1;
cell_id = -1
fcx = -1;
fcy = -1;
num = 0;

/*******ADDING WORDS IN GAME*********/
add_words_easy();

word = "";
word_length = 0;
size_words_to_find = 0;
for(_xp = 0; _xp &lt; board_h; _xp++)
{
    for(_yp = 0;_yp &lt; board_w; _yp++)
    {
        map_cell[_xp, _yp] = ds_map_create();
        ds_map_add(map_cell[_xp, _yp],"id", -1);
        ds_map_add(map_cell[_xp, _yp],"first", -1);
        ds_map_add(map_cell[_xp, _yp],"last", -1);
        ds_map_add(map_cell[_xp, _yp],"cor", board_font_color);
        ds_map_add(map_cell[_xp, _yp], "reversed", 0);
        ds_map_add(map_cell[_xp, _yp],"ativo", 0);
    }
}

for(i = 0; i &lt; ds_list_size(words); i++)
{
    word_tentativa[i, 0] = words[|i];
    word_tentativa[i, 1] = tentativa;
}

//дальше идет уличная магия

//Faça
do
{
    //Tempo de criação
    time_to_create += 0.1;
    
    //ESCOLHE A PALAVRA
    
    if(!ds_list_empty(words))
    {
        //Bagunça a lista de palavras criada através da lista criada pelo arquivo.txt em included files
        ds_list_shuffle(words);
        
        //A palavra se torna o primeiro valor da lista bagunçada
        word = words[|0];
    }
    else
    {
        word = "";
    }
    
    for(i = 0; i &lt; array_height_2d(word_tentativa); i++)
    {
        if(word_tentativa[i, 0] == word)
        {
            if(word_tentativa[i, 1] &gt; 0)
            {
                word_tentativa[i, 1] -= 1;
                
                show_debug_message(string(word) + " : " + string(word_tentativa[i, 1]));
            }
            else
            {
                ds_list_delete(words, 0);
                
                if(!ds_list_empty(words))
                {
                    //Bagunça a lista de palavras criada através da lista criada pelo arquivo.txt em included files
                    ds_list_shuffle(words);
                    
                    //A palavra se torna o primeiro valor da lista bagunçada
                    word = words[|0];
                }
                else
                {
                    word = "";
                }
            }
            i = array_height_2d(word_tentativa);
        }
    }
    
    //Pega o tamanho em letras da palavra selecionada
    word_length = string_length(word);
    
    //тут выбирается направление и поворотность слова
    
    if(word_length &gt; 0)
    {    
        //Escolhe uma opção de organização
        opcoes = choose("horizontal", "vertical", "diagonal_principal", "diagonal_secundaria");
        
        //De acordo com as opções
        switch(opcoes)
        {
            //Se for horizontal
            case "horizontal":
                //Executa o script para criar a palavra na horizontal
                scr_horizontal();
                break;
            //Se for vertical
            case "vertical":
                //Executa o script para criar a palavra na vertical
                scr_vertical();
                break;
            //Se for diagonal principal
            case "diagonal_principal":
                //Executa o script para criar a palavra na diagonal principal
                scr_diagonal_principal();
                break;
            //Se for diagonal secundária
            case "diagonal_secundaria":
                //Executa o script para criar a palavra na diagonal secundária
                scr_diagonal_secundaria();
                break;
        }
    }
    //Se a lista de palavras estiver vazia, ou seja, se já terminou de adicionar todas as palavras
    if(ds_list_empty(words))
    {
        //Faz a repetição no tamanho da largura do quadro
        for(_xp = 0; _xp &lt; board_h; _xp++)
        {
            //Faz a repetição no tamanho da altura do quadro
            for(_yp = 0; _yp &lt; board_w; _yp++)
            {
                //Se não houver nenhuma letra nesta celula
                if(ds_grid_get(board, _xp, _yp) == 0)
                {
                    ds_map_replace(map_cell[_xp, _yp], "cor", board_font_color);
                    
                    //Список допустимого размера символов в доске, которая заполняется9не влияет на слова из скрипта)
                    letter = irandom_range(1040, 1071);
                    
                    //Seta o valor do quadro para a letra selecionada acima
                    ds_grid_set(board, _xp, _yp, chr(letter));
                }
            }
        }
    }
}
until ds_list_size(words) == 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init background vars

//Переменные для рисования фона и игровых объектов.

backRedLinePoint = round(room_width*0.4); //Ставим линию на 40% ширины экрана
backRedLinePointEnd = room_height;
backRedLineColour = c_red;
backBackgroudImage = bkg_paper;
backTimerPointX = backRedLinePoint/2-12;
backTimerPointY = 90;
backWordsToFindPointX = backRedLinePoint/2;
backWordsToFindPointY = 210;

//Применяется для определения строчки найденного слова
tempFoundWordIndex = 0; 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init timer

seconds=0;
minutes=0;
time=0;

alarm[0]=1*room_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Memory free on deleting 

ds_grid_destroy(board);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Time Travel

alarm[0]=1*room_speed;
seconds++;

if seconds&gt;59
{
    seconds=0;
    minutes++;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_angle+=5
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>mouse_pressed = 0;

gx = x_to_gx(mouse_x);
gy = y_to_gy(mouse_y);

if((gx &lt; board_w &amp;&amp; gy &lt; board_h) &amp;&amp; (gx &gt;= 0 &amp;&amp; gy &gt;= 0))
{
    last_cell = ds_map_find_value(map_cell[gx, gy], "last");
    reversed_find = ds_map_find_value(map_cell[gx, gy], "reversed");
    if((fcx &gt; gx &amp;&amp; fcy == gy) || (fcx &lt; gx &amp;&amp; fcy == gy))
    {
        position = "horizontal";
    }    
    else if((fcx == gx &amp;&amp; fcy &gt; gy) || (fcx == gx &amp;&amp; fcy &lt; gy))
    {
        position = "vertical";
    }
    else if((fcx &gt; gx &amp;&amp; fcy &gt; gy) || (fcx &lt; gx &amp;&amp; fcy &lt; gy))
    {
        position = "diagonal_principal";
    }
    else
    {
        if((fcx &gt; gx &amp;&amp; fcy &lt; gy) || (fcx &lt; gx &amp;&amp; fcy &gt; gy))
        {
            position = "diagonal_secundaria";
        }
    }
    
    ds_list_clear(word_list_release);

    if(last_cell == -1)
    {
        last_cell = ds_map_find_value(map_cell[gx, gy], "first");
        reversed_find = ds_map_find_value(map_cell[gx, gy], "reversed");
    }
    
    if(last_cell == 1)
    {
        cell_release = ds_map_find_value(map_cell[gx, gy], "id");
        
        if(cell_pressed != cell_release)
        {
            ativo = ds_map_find_value(map_cell[gx, gy], "ativo");
            
            if(ativo &gt; 0)
            {
                for(i = ativo; i &gt; 0; i--)
                {
                    ds_list_add(word_list_release, ds_map_find_value(map_cell[gx, gy],"word_" + string(i)));
                }
                
                size_pressed = ds_list_size(word_list_pressed);
                size_release = ds_list_size(word_list_release);
                
                for(i = 0; i &lt; size_pressed; i++)
                {
                    for(j = 0; j &lt; size_release; j++)
                    {
                        if(word_list_pressed[|i] == word_list_release[|j])
                        {
                            word_find = word_list_pressed[|i];
                            show_debug_message(string(words_to_find[|i]) + ' ' + string(word_find));
                            word_find_length = string_length(word_find);
                            if(position == "horizontal")
                            {                            
                                if(gx &lt; fcx)
                                {
                                    for(k = 0; k &lt; word_find_length; k++)
                                    {
                                        ativo = ds_map_find_value(map_cell[gx + k, gy], "ativo");
                                        
                                        if(ativo == 1)
                                        {
                                            ativo -= 1;
                                        }
                                        
                                        ds_map_replace(map_cell[gx + k, gy], "ativo", ativo);
                                        ds_map_replace(map_cell[gx + k, gy], "cor", board_font_revela_color);
                                        
                                        
                                        if(reversed_find == 1)
                                        {
                                            word_find = reverseString(word_find);                                    
                                        }
                                        
                                        ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                        
                                    }
                                }
                                else
                                {
                                    if(gx &gt; fcx)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx - k, gy], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                            
                                            ds_map_replace(map_cell[gx - k, gy], "ativo", ativo);
                                            ds_map_replace(map_cell[gx - k, gy], "cor", board_font_revela_color);
                                            
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);
                                            }
                                            
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                            
                                        }
                                    }
                                }
                            }
                            else if(position == "vertical")
                            {
                                if(gy &lt; fcy)
                                {
                                    for(k = 0; k &lt; word_find_length; k++)
                                    {
                                        ativo = ds_map_find_value(map_cell[gx, gy + k], "ativo");
                                        
                                        if(ativo == 1)
                                        {
                                            ativo -= 1;
                                        }
                                        
                                        ds_map_replace(map_cell[gx, gy + k], "ativo", ativo);
                                        ds_map_replace(map_cell[gx, gy + k], "cor", board_font_revela_color);
                                        
                                        if(reversed_find == 1)
                                        {
                                            word_find = reverseString(word_find);                                    
                                        }
                                        
                                        ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                        
                                    }
                                }
                                else
                                {
                                    if(gy &gt; fcy)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx, gy - k], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                            
                                            ds_map_replace(map_cell[gx, gy - k], "ativo", ativo);
                                            ds_map_replace(map_cell[gx, gy - k], "cor", board_font_revela_color);
                                            
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);                                    
                                            }
                                            
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                            
                                        }
                                    }
                                }
                            }
                            else if(position == "diagonal_principal")
                            {
                                if(gx &lt; fcx)
                                {
                                    for(k = 0; k &lt; word_find_length; k++)
                                    {
                                        ativo = ds_map_find_value(map_cell[gx + k, gy + k], "ativo");
                                        
                                        if(ativo == 1)
                                        {
                                            ativo -= 1;
                                        }
                                        
                                        ds_map_replace(map_cell[gx + k, gy + k], "ativo", ativo);
                                        ds_map_replace(map_cell[gx + k, gy + k], "cor", board_font_revela_color);
                                        
                                        if(reversed_find == 1)
                                        {
                                            word_find = reverseString(word_find);                                    
                                        }
                                        
                                        ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                        
                                    }
                                }
                                else
                                {
                                    if(gx &gt; fcx)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx - k, gy - k], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                            
                                            ds_map_replace(map_cell[gx - k, gy - k], "ativo", ativo);
                                            ds_map_replace(map_cell[gx - k, gy - k], "cor", board_font_revela_color);
                                            
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);                                    
                                            }
                                            
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                            
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if(position == "diagonal_secundaria")
                                {
                                    if(gx &lt; fcx)
                                    {
                                        for(k = 0; k &lt; word_find_length; k++)
                                        {
                                            ativo = ds_map_find_value(map_cell[gx + k, gy - k], "ativo");
                                            
                                            if(ativo == 1)
                                            {
                                                ativo -= 1;
                                            }
                                                        
                                            ds_map_replace(map_cell[gx + k, gy - k], "ativo", ativo);
                                            ds_map_replace(map_cell[gx + k, gy - k], "cor", board_font_revela_color);
                                                        
                                            if(reversed_find == 1)
                                            {
                                                word_find = reverseString(word_find);                                    
                                            }
                                                        
                                            ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                            
                                        }
                                    }
                                    else
                                    {
                                        if(gx &gt; fcx)
                                        {
                                            for(k = 0; k &lt; word_find_length; k++)
                                            {
                                                ativo = ds_map_find_value(map_cell[gx - k, gy + k], "ativo");
                                                                
                                                if(ativo == 1)
                                                {
                                                    ativo -= 1;
                                                }
                                                                
                                                ds_map_replace(map_cell[gx - k, gy + k], "ativo", ativo);
                                                ds_map_replace(map_cell[gx - k, gy + k], "cor", board_font_revela_color);
                                                                
                                                if(reversed_find == 1)
                                                {
                                                    word_find = reverseString(word_find);                                    
                                                }
                                                                
                                                ds_map_replace(map_lista, "cor_" + string(word_find), list_font_revela_color);
                                                
                                            }
                                        }
                                    }
                                }
                            }
                            amount_words_find += 1;
                            for(i = 0; i &lt; ds_list_size(words_to_find); i++){                                   
                                    w = words_to_find[|i];
                                    if ds_map_find_value(map_lista, "palavra_" + string(w)) = word_find then tempFoundWordIndex = i;
                                    //draw_text(backWordsToFindPointX, backWordsToFindPointY + (60 * i), ds_map_find_value(map_lista, "palavra_" + string(w)));
                                    //draw_line_width(mouse_xstart, mouse_ystart, mouse_x, mouse_y, 60);
                                }
                            
                            
                            
                            
                            
    
                            //if word_find = ds_map_find_value(words_to_find,word_find) then show_debug_message('YES');
                            //show_debug_message(ds_map_find_value(words_to_find,word_find) + ' ' + string(word_find));
                            
                            //word_find
                            //tempFoundWordIndex
                            
                            
                            scr_createLine();
                            if(amount_words_find == ds_list_size(words_to_find))
                            {
                                show_message("Отлично!");
                            }
                            
                            i = size_pressed;
                            j = size_release;
                        }
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>gx = x_to_gx(mouse_x);
gy = y_to_gy(mouse_y);
line_color = make_color_rgb(irandom(255),irandom(255),irandom(255));

if((gx &lt; board_w &amp;&amp; gy &lt; board_h) &amp;&amp; (gx &gt;= 0 &amp;&amp; gy &gt;= 0))
{
    //DESENHA A SELEÇÃO
    mouse_pressed = 1;
    
    mouse_xstart = mouse_x;
    mouse_ystart = mouse_y;
    //FIM DA SELEÇÃO

    first_cell = ds_map_find_value(map_cell[gx, gy], "first");
    ds_list_clear(word_list_pressed);

    if first_cell == -1
    {
        first_cell = ds_map_find_value(map_cell[gx, gy], "last");
    }
    
    if(first_cell == 1)
    {
        fcx = gx;
        fcy = gy;
        
        cell_pressed = ds_map_find_value(map_cell[gx, gy], "id");
        
        ativo = ds_map_find_value(map_cell[gx, gy], "ativo");
        
        if(ativo &gt; 0)
        {            
            for(i = ativo; i &gt; 0; i--)
            {
                ds_list_add(word_list_pressed, ds_map_find_value(map_cell[gx, gy], "word_" + string(i)));
            }
        }
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_grid_destroy(board);
ds_list_destroy(words);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Background

draw_background_tiled(backBackgroudImage,backRedLinePoint,0); //Рисуем тайловым повторением фон со сдвигом на точку красной линии

draw_line_colour(backRedLinePoint,0,backRedLinePoint,backRedLinePointEnd,backRedLineColour,backRedLineColour); //Красная линия




/*
// Arrow the circle accuracy.
draw_set_circle_precision(64);

// Draw the picture on the background
draw_set_alpha(board_alpha);

// Frame letters
draw_roundrect_colour_ext(x - 16, y - 16, x + (board_w * 32) + 16, y + (board_h * 32) + 16, 32, 32, board_colorA, board_colorB, 0);
draw_roundrect_colour_ext(x - 20, y - 20, x + (board_w * 32) + 20, y + (board_h * 32) + 20, 32, 32, board_colorA, board_colorB, 1);
draw_set_alpha(1);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the words.

draw_set_font(fnt_timerNew);

for(_xp = 0; _xp &lt; board_w; _xp++)
{
    for(_yp = 0;_yp &lt; board_h; _yp++)
    {
        draw_set_valign(fa_middle);
        draw_set_halign(fa_center);
        
        cor = ds_map_find_value(map_cell[_xp, _yp], "cor")
        draw_set_colour(cor);
        
        // DRAW THE LETTERS
        draw_text(x + (_xp * 60) + 48, y + (_yp * 60) + 48, board[#_xp, _yp]);
    }
}

// Draw the rest of the letters.
if(!ds_list_empty(words))
{
    for(i = 0; i &lt; ds_list_size(words); i++)
    {
        draw_text(512, 384 + (60 * i), words[|i]);
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the words to be found

if(size_words_to_find &gt; 0)
{    
    for(i = 0; i &lt; ds_list_size(words_to_find); i++)
    {
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        
        w = words_to_find[|i];        
        draw_set_colour(ds_map_find_value(map_lista, "cor_" + string(w)));
        
        draw_text(backWordsToFindPointX, backWordsToFindPointY + (60 * i), ds_map_find_value(map_lista, "palavra_" + string(w)));
        //draw_line_width(mouse_xstart, mouse_ystart, mouse_x, mouse_y, 60);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Line

// Draw the line below the letters
if(mouse_pressed == 1)
{
    draw_set_colour(line_color);
    draw_set_alpha(0.4);
    draw_line_width(mouse_xstart, mouse_ystart, mouse_x, mouse_y, 60);
    //draw_circle(mouse_xstart, mouse_ystart, 16, 0);
    //draw_circle(mouse_x, mouse_y, 16, 0);
    draw_set_color($FFFFFF);
    draw_set_alpha(1);
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw timer

draw_set_colour(make_colour_rgb(0,74,127));
draw_set_font(fnt_timerNew);
draw_set_halign(fa_right);
if minutes &lt; 10 draw_text(backTimerPointX,backTimerPointY,string(minutes)+ " ") else draw_text(backTimerPointX,backTimerPointY," "+string(minutes)+ " ");
draw_set_halign(fa_left);
if seconds &lt; 10 draw_text(backTimerPointX,backTimerPointY," 0"+string(seconds)) else draw_text(backTimerPointX,backTimerPointY," "+string(seconds));
draw_set_halign(fa_center);
draw_text(backTimerPointX,backTimerPointY,":");


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
